# 技術架構文件
## Technical Architecture

**版本：** v1.0
**適用範圍：** 數位化兵棋部署與沙盤推演系統

---

## 一、架構概論

### 1.1 設計原則

| 原則 | 說明 |
|------|------|
| **模組化** | 各模組獨立開發，低耦合高內聚 |
| **資料驅動** | UI 與 3D 場景皆由單一狀態源驅動 |
| **可擴展** | 支援外掛式功能擴展 |
| **效能優先** | 大量單位場景下仍保持 60 FPS |
| **型別安全** | 全面使用 TypeScript |

### 1.2 整體架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                         表現層 (Presentation)                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Vue 3 組件樹                       │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │   │
│  │  │ 工具列  │ │ 屬性面板│ │ ORBAT樹 │ │ 時間軸  │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       狀態管理層 (State Management)           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                      Pinia Store                    │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ ORBATStore│ │SceneStore│ │UIStore   │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       業務邏輯層 (Business Logic)             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                      Service Layer                  │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ORBATService│SymbolEngine│TerrainSvc│           │   │
│  │  └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                        核心層 (Core)                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Three.js 引擎核心                   │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │SceneManager│CameraController│ LODManager│      │   │
│  │  └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       工具層 (Utils)                        │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐     │
│  │座標轉換   │ │射線檢測   │ │幾何運算   │ │事件匯流排│     │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘     │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、核心系統設計

### 2.1 場景管理器 (SceneManager)

場景管理器是整個 3D 系統的核心，負責協調所有渲染物件。

```typescript
/**
 * 場景管理器
 */
class SceneManager {
  // Three.js 核心物件
  private scene: THREE.Scene;
  private renderer: THREE.WebGLRenderer;
  private camera: THREE.PerspectiveCamera;

  // 場景容器
  private terrainContainer: THREE.Group;
  private unitsContainer: THREE.Group;
  private graphicsContainer: THREE.Group;

  // 管理器實例
  private terrainManager: TerrainManager;
  private unitManager: UnitManager;
  private lodManager: LODManager;
  private graphicsManager: GraphicsManager;

  /**
   * 初始化場景
   */
  initialize(canvas: HTMLCanvasElement): void {
    // 建立 Three.js 基礎物件
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true
    });
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight,
      0.1, // Near
      10000 // Far
    );

    // 建立場景容器
    this.terrainContainer = new THREE.Group();
    this.unitsContainer = new THREE.Group();
    this.graphicsContainer = new THREE.Group();

    this.scene.add(this.terrainContainer);
    this.scene.add(this.unitsContainer);
    this.scene.add(this.graphicsContainer);

    // 初始化各管理器
    this.terrainManager = new TerrainManager(this.terrainContainer);
    this.unitManager = new UnitManager(this.unitsContainer);
    this.lodManager = new LODManager(this.camera);
    this.graphicsManager = new GraphicsManager(this.graphicsContainer);

    // 啟動渲染循環
    this.startRenderLoop();
  }

  /**
   * 渲染循環
   */
  private startRenderLoop(): void {
    const animate = () => {
      requestAnimationFrame(animate);

      // 更新 LOD
      this.lodManager.update();

      // 渲染場景
      this.renderer.render(this.scene, this.camera);
    };
    animate();
  }

  /**
   * 載入場景
   */
  async loadScene(sceneData: Scene): Promise<void> {
    // 載入地形
    await this.terrainManager.loadTerrain(sceneData.terrain);

    // 載入單位
    for (const [uuid, unit] of Object.entries(sceneData.units)) {
      await this.unitManager.addUnit(unit);
    }

    // 載入戰術圖形
    for (const graphic of sceneData.graphics) {
      this.graphicsManager.addGraphic(graphic);
    }
  }

  /**
   * 清空場景
   */
  clearScene(): void {
    this.unitManager.clear();
    this.graphicsManager.clear();
    this.terrainManager.clear();
  }

  /**
   * 調整大小
   */
  resize(width: number, height: number): void {
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
  }
}
```

### 2.2 單位管理器 (UnitManager)

管理所有單位的建立、更新、移除。

```typescript
/**
 * 單位管理器
 */
class UnitManager {
  private container: THREE.Group;
  private units: Map<string, UnitEntity> = new Map();

  constructor(container: THREE.Group) {
    this.container = container;
  }

  /**
   * 新增單位
   */
  async addUnit(unitData: Unit): Promise<UnitEntity> {
    // 建立單位實體
    const entity = new UnitEntity(unitData);

    // 載入 3D 模型
    await entity.loadModel();

    // 生成符號
    entity.generateSymbol();

    // 加入場景
    this.container.add(entity.mesh);
    this.units.set(unitData.uuid, entity);

    return entity;
  }

  /**
   * 更新單位
   */
  updateUnit(uuid: string, updates: Partial<Unit>): void {
    const entity = this.units.get(uuid);
    if (!entity) {
      throw new Error(ErrorCode.UNIT_NOT_FOUND);
    }
    entity.update(updates);
  }

  /**
   * 移除單位
   */
  removeUnit(uuid: string): void {
    const entity = this.units.get(uuid);
    if (!entity) {
      throw new Error(ErrorCode.UNIT_NOT_FOUND);
    }

    // 從場景移除
    this.container.remove(entity.mesh);

    // 釋放資源
    entity.dispose();

    // 從地圖移除
    this.units.delete(uuid);
  }

  /**
   * 取得單位
   */
  getUnit(uuid: string): UnitEntity | undefined {
    return this.units.get(uuid);
  }

  /**
   * 取得所有單位
   */
  getAllUnits(): UnitEntity[] {
    return Array.from(this.units.values());
  }

  /**
   * 清空所有單位
   */
  clear(): void {
    for (const entity of this.units.values()) {
      this.container.remove(entity.mesh);
      entity.dispose();
    }
    this.units.clear();
  }
}
```

### 2.3 單位實體 (UnitEntity)

單位在 3D 場景中的具體實現。

```typescript
/**
 * 單位實體
 */
class UnitEntity {
  // 資料
  public data: Unit;

  // 3D 物件
  public mesh: THREE.Group;
  private modelMesh?: THREE.Group;
  private symbolSprite?: THREE.Sprite;
  private labelSprite?: THREE.Sprite;

  /**
   * 建構函式
   */
  constructor(data: Unit) {
    this.data = data;
    this.mesh = new THREE.Group();

    // 設定位置與旋轉
    this.updateTransform();
  }

  /**
   * 載入 3D 模型
   */
  async loadModel(): Promise<void> {
    const loader = new GLTFLoader();
    const url = `/assets/models/${this.data.asset.modelPath}`;

    try {
      const gltf = await loader.loadAsync(url);
      this.modelMesh = gltf.scene;

      // 套用縮放
      this.modelMesh.scale.setScalar(this.data.asset.scale);

      // 初始隱藏（由 LOD 控制）
      this.modelMesh.visible = false;

      this.mesh.add(this.modelMesh);
    } catch (error) {
      console.error(`模型載入失敗: ${url}`, error);
    }
  }

  /**
   * 生成符號
   */
  generateSymbol(): void {
    // 使用符號引擎生成材質
    const texture = SymbolEngine.generateTexture(this.data.sidc);

    // 建立 Sprite
    const material = new THREE.SpriteMaterial({
      map: texture.canvas,
      transparent: true
    });

    this.symbolSprite = new THREE.Sprite(material);

    // 設定大小
    const size = this.data.symbolSize || 32;
    this.symbolSprite.scale.set(size, size, 1);

    // 設定高度偏移
    const offset = this.data.visual.labelOffset || 5;
    this.symbolSprite.position.y = offset;

    this.mesh.add(this.symbolSprite);
  }

  /**
   * 更新變換
   */
  private updateTransform(): void {
    const { position, rotation } = this.data.transform;
    this.mesh.position.set(position.x, position.y, position.z);

    // 將歐拉角轉為弧度
    this.mesh.rotation.y = THREE.MathUtils.degToRad(rotation.y);
  }

  /**
   * 更新單位
   */
  update(updates: Partial<Unit>): void {
    // 合併更新資料
    this.data = { ...this.data, ...updates };

    // 更新變換
    if (updates.transform) {
      this.updateTransform();
    }

    // 更新符號
    if (updates.sidc) {
      this.regenerateSymbol();
    }
  }

  /**
   * 重新生成符號
   */
  private regenerateSymbol(): void {
    if (this.symbolSprite) {
      this.mesh.remove(this.symbolSprite);
      this.symbolSprite.material.dispose();
    }
    this.generateSymbol();
  }

  /**
   * 設定 LOD 顯示
   */
  setLOD(lod: LODLevel): void {
    if (!this.modelMesh || !this.symbolSprite) return;

    switch (lod) {
      case LODLevel.STRATEGIC:
        this.modelMesh.visible = false;
        this.symbolSprite.visible = true;
        break;

      case LODLevel.OPERATIONAL:
        this.modelMesh.visible = false;
        this.symbolSprite.visible = true;
        break;

      case LODLevel.TACTICAL:
        this.modelMesh.visible = true;
        this.symbolSprite.visible = true;
        break;

      case LODLevel.DETAIL:
        this.modelMesh.visible = true;
        this.symbolSprite.visible = true;
        break;
    }
  }

  /**
   * 釋放資源
   */
  dispose(): void {
    // 釋放材質
    if (this.symbolSprite) {
      this.symbolSprite.material.dispose();
    }

    // 釋放幾何
    if (this.modelMesh) {
      this.modelMesh.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          child.geometry.dispose();
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
    }
  }
}
```

---

## 三、符號引擎設計

### 3.1 符號引擎架構

```typescript
/**
 * 符號引擎
 */
class SymbolEngine {
  private static cache: Map<string, SymbolTexture> = new Map();

  /**
   * 生成符號貼圖
   */
  static generateTexture(sidc: string): SymbolTexture {
    // 檢查快取
    const cached = this.cache.get(sidc);
    if (cached) {
      return cached;
    }

    // 解析 SIDC
    const parsed = this.parseSIDC(sidc);

    // 建立畫布
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const size = 128;
    canvas.width = size;
    canvas.height = size;

    // 繪製符號
    this.drawSymbol(ctx, parsed, size);

    // 建立貼圖物件
    const texture: SymbolTexture = {
      uuid: generateUUID(),
      sidc,
      canvas,
      dataURL: canvas.toDataURL(),
      size: { width: size, height: size },
      material: null // 由呼叫方建立
    };

    // 存入快取
    this.cache.set(sidc, texture);

    return texture;
  }

  /**
   * 解析 SIDC
   */
  private static parseSIDC(sidc: string): ParsedSIDC {
    if (sidc.length !== 20) {
      throw new Error(ErrorCode.SYMBOL_INVALID_SIDC);
    }

    return {
      version: sidc[0],
      identity: sidc[1] as Identity,
      exercise: sidc[2],
      domain: sidc.slice(3, 5),
      entityType: sidc.slice(5, 10),
      specificType: sidc.slice(10, 14),
      modifier: sidc.slice(14, 17),
      status: sidc.slice(17, 20)
    };
  }

  /**
   * 繪製符號
   */
  private static drawSymbol(
    ctx: CanvasRenderingContext2D,
    parsed: ParsedSIDC,
    size: number
  ): void {
    const center = size / 2;
    const halfSize = size / 2 - 4; // 預留邊距

    // 設定顏色（依身份）
    const color = this.getIdentityColor(parsed.identity);
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 3;

    // 繪製框架
    this.drawFrame(ctx, center, halfSize, parsed);

    // 繪製圖標
    this.drawIcon(ctx, center, halfSize, parsed);

    // 繪製修飾符
    this.drawModifiers(ctx, center, halfSize, parsed);
  }

  /**
   * 取得身份顏色
   */
  private static getIdentityColor(identity: Identity): string {
    switch (identity) {
      case Identity.FRIEND:
        return '#00FFFF'; // 青色（友軍）
      case Identity.HOSTILE:
        return '#FF0000'; // 紅色（敵軍）
      case Identity.NEUTRAL:
        return '#00FF00'; // 綠色（中立）
      case Identity.UNKNOWN:
        return '#FFFF00'; // 黃色（未知）
      default:
        return '#FFFFFF';
    }
  }

  /**
   * 繪製框架
   */
  private static drawFrame(
    ctx: CanvasRenderingContext2D,
    center: number,
    halfSize: number,
    parsed: ParsedSIDC
  ): void {
    const domain = parsed.domain;

    ctx.beginPath();

    // 陸戰 (10): 矩形
    if (domain === '10') {
      ctx.rect(center - halfSize, center - halfSize, halfSize * 2, halfSize * 2);
    }
    // 空戰 (30): 菱形
    else if (domain === '30') {
      ctx.moveTo(center, center - halfSize);
      ctx.lineTo(center + halfSize, center);
      ctx.lineTo(center, center + halfSize);
      ctx.lineTo(center - halfSize, center);
      ctx.closePath();
    }
    // 海戰 (50): 四角形
    else if (domain === '50') {
      ctx.rect(center - halfSize * 0.8, center - halfSize * 0.8, halfSize * 1.6, halfSize * 1.6);
    }

    ctx.stroke();
  }

  /**
   * 繪製圖標
   */
  private static drawIcon(
    ctx: CanvasRenderingContext2D,
    center: number,
    halfSize: number,
    parsed: ParsedSIDC
  ): void {
    // 依實體類型繪製對應圖標
    const entityType = parsed.entityType;

    // 簡化示例：裝甲單位繪製橫線
    if (entityType === '00015') { // 裝甲
      ctx.beginPath();
      ctx.moveTo(center - halfSize * 0.4, center);
      ctx.lineTo(center + halfSize * 0.4, center);
      ctx.stroke();
    }
    // 其他類型...
  }

  /**
   * 繪製修飾符
   */
  private static drawModifiers(
    ctx: CanvasRenderingContext2D,
    center: number,
    halfSize: number,
    parsed: ParsedSIDC
  ): void {
    // 繪制指揮官星號、任務修飾符等
    const modifier = parsed.modifier;

    if (modifier === '000') {
      // 無修飾符
      return;
    }

    // 範例：指揮官加一顆星
    if (modifier === '100') {
      this.drawStar(ctx, center, halfSize * 0.3, 5, 0.5);
    }
  }

  /**
   * 繪製星星
   */
  private static drawStar(
    ctx: CanvasRenderingContext2D,
    cx: number,
    cy: number,
    outerRadius: number,
    innerRadius: number,
    points: number
  ): void {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = (Math.PI * i) / points - Math.PI / 2;
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    ctx.fill();
  }

  /**
   * 清除快取
   */
  static clearCache(): void {
    this.cache.clear();
  }
}

/**
 * 解析後的 SIDC
 */
interface ParsedSIDC {
  version: string;
  identity: Identity;
  exercise: string;
  domain: string;
  entityType: string;
  specificType: string;
  modifier: string;
  status: string;
}

/**
 * 身份
 */
enum Identity {
  FRIEND = '0',
  HOSTILE = '1',
  NEUTRAL = '2',
  UNKNOWN = '3'
}
```

---

## 四、LOD 系統設計

### 4.1 LOD 管理器

```typescript
/**
 * LOD 管理器
 */
class LODManager {
  private camera: THREE.PerspectiveCamera;
  private levels: LODConfig[] = DEFAULT_LOD_LEVELS;
  private unitEntities: Set<UnitEntity> = new Set();

  constructor(camera: THREE.PerspectiveCamera) {
    this.camera = camera;
  }

  /**
   * 註冊單位
   */
  registerUnit(entity: UnitEntity): void {
    this.unitEntities.add(entity);
  }

  /**
   * 註銷單位
   */
  unregisterUnit(entity: UnitEntity): void {
    this.unitEntities.delete(entity);
  }

  /**
   * 設定 LOD 級別
   */
  setLevels(levels: LODConfig[]): void {
    this.levels = levels.sort((a, b) => a.minDistance - b.minDistance);
  }

  /**
   * 更新（每幀調用）
   */
  update(): void {
    const cameraPos = this.camera.position;

    for (const entity of this.unitEntities) {
      // 計算距離
      const distance = cameraPos.distanceTo(entity.mesh.position);

      // 決定 LOD 級別
      const lod = this.getLODForDistance(distance);

      // 套用 LOD
      entity.setLOD(lod);
    }
  }

  /**
   * 依距離取得 LOD 級別
   */
  private getLODForDistance(distance: number): LODLevel {
    // 從遠到近查找
    for (let i = this.levels.length - 1; i >= 0; i--) {
      const level = this.levels[i];
      if (distance >= level.minDistance) {
        return level.level;
      }
    }
    return LODLevel.DETAIL;
  }
}
```

---

## 五、地形系統設計

### 5.1 地形管理器

```typescript
/**
 * 地形管理器
 */
class TerrainManager {
  private container: THREE.Group;
  private terrain?: THREE.Mesh;
  private config?: TerrainConfig;

  constructor(container: THREE.Group) {
    this.container = container;
  }

  /**
   * 載入地形
   */
  async loadTerrain(config: TerrainConfig): Promise<void> {
    this.config = config;

    // 清除舊地形
    this.clear();

    switch (config.type) {
      case TerrainType.HEIGHTMAP:
        await this.loadHeightmapTerrain(config);
        break;

      case TerrainType.FLAT:
        this.loadFlatTerrain(config);
        break;

      default:
        throw new Error(`不支援的地形類型: ${config.type}`);
    }
  }

  /**
   * 載入高程地形
   */
  private async loadHeightmapTerrain(config: TerrainConfig): Promise<void> {
    const { heightmap, size } = config;

    // 載入高程圖
    const heightData = await this.loadHeightmap(heightmap.path);

    // 建立地形幾何
    const segmentsX = Math.floor(size.width / heightmap.resolution);
    const segmentsZ = Math.floor(size.height / heightmap.resolution);

    const geometry = new THREE.PlaneGeometry(
      size.width,
      size.height,
      segmentsX,
      segmentsZ
    );

    // 套用高度
    this.applyHeightmap(geometry, heightData, heightmap);

    // 旋轉為水平
    geometry.rotateX(-Math.PI / 2);

    // 建立材質
    const material = this.createTerrainMaterial(config);

    // 建立 Mesh
    this.terrain = new THREE.Mesh(geometry, material);
    this.container.add(this.terrain);
  }

  /**
   * 載入高程圖資料
   */
  private async loadHeightmap(path: string): Promise<Uint8Array> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d')!;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        resolve(new Uint8Array(imageData.data.buffer));
      };
      img.onerror = reject;
      img.src = `/assets/textures/${path}`;
    });
  }

  /**
   * 套用高程圖
   */
  private applyHeightmap(
    geometry: THREE.PlaneGeometry,
    heightData: Uint8Array,
    config: HeightmapConfig
  ): void {
    const positions = geometry.attributes.position.array as Float32Array;
    const vertexCount = positions.length / 3;

    for (let i = 0; i < vertexCount; i++) {
      // 取得紅色通道作為高度
      const heightValue = heightData[i * 4];

      // 正規化到 0-1
      const normalized = heightValue / 255;

      // 對應到實際高度
      const height =
        config.minHeight +
        normalized * (config.maxHeight - config.minHeight);

      // 設定 Y 座標（索引 * 3 + 1）
      positions[i * 3 + 1] = height;
    }

    // 重新計算法線
    geometry.computeVertexNormals();
  }

  /**
   * 建立地形材質
   */
  private createTerrainMaterial(config: TerrainConfig): THREE.Material {
    // 多層混合材質
    return new THREE.MeshStandardMaterial({
      color: 0x3d5c3d,
      roughness: 0.8,
      metalness: 0.1,
      flatShading: false
    });
  }

  /**
   * 載入平面地形
   */
  private loadFlatTerrain(config: TerrainConfig): void {
    const geometry = new THREE.PlaneGeometry(
      config.size.width,
      config.size.height
    );
    geometry.rotateX(-Math.PI / 2);

    const material = new THREE.MeshStandardMaterial({
      color: 0x3d5c3d,
      roughness: 0.8
    });

    this.terrain = new THREE.Mesh(geometry, material);
    this.container.add(this.terrain);
  }

  /**
   * 取得地形高度
   */
  getTerrainHeight(x: number, z: number): number {
    if (!this.terrain) return 0;

    // 簡化版：使用 Raycasting
    const raycaster = new THREE.Raycaster();
    raycaster.set(
      new THREE.Vector3(x, 1000, z),
      new THREE.Vector3(0, -1, 0)
    );

    const intersects = raycaster.intersectObject(this.terrain);

    if (intersects.length > 0) {
      return intersects[0].point.y;
    }

    return 0;
  }

  /**
   * 清除地形
   */
  clear(): void {
    if (this.terrain) {
      this.container.remove(this.terrain);
      this.terrain.geometry.dispose();
      (this.terrain.material as THREE.Material).dispose();
      this.terrain = undefined;
    }
  }
}
```

---

## 六、戰術標繪系統設計

### 6.1 圖形管理器

```typescript
/**
 * 戰術圖形管理器
 */
class GraphicsManager {
  private container: THREE.Group;
  private graphics: Map<string, GraphicEntity> = new Map();
  private terrainManager: TerrainManager;

  constructor(container: THREE.Group, terrainManager: TerrainManager) {
    this.container = container;
    this.terrainManager = terrainManager;
  }

  /**
   * 新增圖形
   */
  addGraphic(graphic: TacticalGraphic): GraphicEntity {
    const entity = new GraphicEntity(graphic, this.terrainManager);
    this.container.add(entity.mesh);
    this.graphics.set(graphic.uuid, entity);
    return entity;
  }

  /**
   * 更新圖形
   */
  updateGraphic(uuid: string, updates: Partial<TacticalGraphic>): void {
    const entity = this.graphics.get(uuid);
    if (!entity) {
      throw new Error('圖形不存在');
    }
    entity.update(updates);
  }

  /**
   * 移除圖形
   */
  removeGraphic(uuid: string): void {
    const entity = this.graphics.get(uuid);
    if (!entity) return;

    this.container.remove(entity.mesh);
    entity.dispose();
    this.graphics.delete(uuid);
  }

  /**
   * 清空所有圖形
   */
  clear(): void {
    for (const entity of this.graphics.values()) {
      this.container.remove(entity.mesh);
      entity.dispose();
    }
    this.graphics.clear();
  }
}

/**
 * 圖形實體
 */
class GraphicEntity {
  public mesh: THREE.Object3D;
  private data: TacticalGraphic;
  private terrainManager: TerrainManager;

  constructor(data: TacticalGraphic, terrainManager: TerrainManager) {
    this.data = data;
    this.terrainManager = terrainManager;
    this.mesh = this.createMesh();
    this.updateTransform();
  }

  /**
   * 建立 Mesh
   */
  private createMesh(): THREE.Object3D {
    switch (this.data.type) {
      case GraphicType.POINT:
        return this.createPoint();

      case GraphicType.LINE:
      case GraphicType.AXIS_OF_ADVANCE:
        return this.createLine();

      case GraphicType.ARROW:
      case GraphicType.ATTACK_ARROW:
        return this.createArrow();

      case GraphicType.AREA:
      case GraphicType.AO:
        return this.createArea();

      case GraphicType.CIRCULAR:
        return this.createCircle();

      default:
        return new THREE.Group();
    }
  }

  /**
   * 建立點位
   */
  private createPoint(): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(2, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: this.data.style.strokeColor
    });
    return new THREE.Mesh(geometry, material);
  }

  /**
   * 建立線條
   */
  private createLine(): THREE.Line {
    const { points } = this.data.geometry;

    if (!points || points.length < 2) {
      throw new Error(ErrorCode.GRAPHIC_INVALID_GEOMETRY);
    }

    // 貼合地形
    const clampedPoints = points.map(p => ({
      x: p.x,
      y: this.terrainManager.getTerrainHeight(p.x, p.z),
      z: p.z
    }));

    const geometry = new THREE.BufferGeometry().setFromPoints(
      clampedPoints.map(p => new THREE.Vector3(p.x, p.y + 0.5, p.z))
    );

    const material = new THREE.LineBasicMaterial({
      color: this.data.style.strokeColor,
      linewidth: this.data.style.strokeWidth
    });

    return new THREE.Line(geometry, material);
  }

  /**
   * 建立箭頭
   */
  private createArrow(): THREE.Group {
    const group = new THREE.Group();
    const { points } = this.data.geometry;

    if (!points || points.length < 2) {
      throw new Error(ErrorCode.GRAPHIC_INVALID_GEOMETRY);
    }

    // 主線條
    const line = this.createLine();
    group.add(line);

    // 箭頭頭部
    const start = points[points.length - 2];
    const end = points[points.length - 1];
    const direction = new THREE.Vector3(
      end.x - start.x,
      0,
      end.z - start.z
    ).normalize();

    const arrowHelper = new THREE.ArrowHelper(
      direction,
      new THREE.Vector3(end.x, end.y, end.z),
      10,
      this.data.style.strokeColor,
      5,
      3
    );

    group.add(arrowHelper);

    return group;
  }

  /**
   * 建立區域
   */
  private createArea(): THREE.Mesh {
    const { vertices } = this.data.geometry;

    if (!vertices || vertices.length < 3) {
      throw new Error(ErrorCode.GRAPHIC_INVALID_GEOMETRY);
    }

    // 貼合地形
    const clampedVertices = vertices.map(v => {
      const y = this.terrainManager.getTerrainHeight(v.x, v.z);
      return new THREE.Vector3(v.x, y + 0.2, v.z);
    });

    const geometry = new THREE.ShapeGeometry(
      new THREE.Shape(clampedVertices.map(v => new THREE.Vector2(v.x, v.z)))
    );

    const material = new THREE.MeshBasicMaterial({
      color: this.data.style.fillColor || this.data.style.strokeColor,
      transparent: true,
      opacity: this.data.style.fillOpacity || 0.3,
      side: THREE.DoubleSide
    });

    // 調整頂點高度
    const positions = geometry.attributes.position.array as Float32Array;
    for (let i = 0; i < positions.length; i += 3) {
      const x = positions[i];
      const z = positions[i + 2];
      positions[i + 1] = this.terrainManager.getTerrainHeight(x, z) + 0.2;
    }

    return new THREE.Mesh(geometry, material);
  }

  /**
   * 建立圓形區域
   */
  private createCircle(): THREE.Mesh {
    const { center, radius, startAngle, endAngle } = this.data.geometry;

    if (!center || radius === undefined) {
      throw new Error(ErrorCode.GRAPHIC_INVALID_GEOMETRY);
    }

    const y = this.terrainManager.getTerrainHeight(center.x, center.z);

    const geometry = new THREE.RingGeometry(
      radius - 0.5,
      radius,
      32
    );

    const material = new THREE.MeshBasicMaterial({
      color: this.data.style.strokeColor,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(center.x, y + 0.2, center.z);
    mesh.rotation.x = -Math.PI / 2;

    return mesh;
  }

  /**
   * 更新圖形
   */
  update(updates: Partial<TacticalGraphic>): void {
    this.data = { ...this.data, ...updates };

    // 重建 Mesh
    const newMesh = this.createMesh();
    this.mesh.parent?.remove(this.mesh);
    this.mesh = newMesh;
  }

  /**
   * 更新變換
   */
  private updateTransform(): void {
    this.mesh.visible = this.data.visible;
  }

  /**
   * 釋放資源
   */
  dispose(): void {
    if (this.mesh instanceof THREE.Mesh) {
      this.mesh.geometry.dispose();
      (this.mesh.material as THREE.Material).dispose();
    }
  }
}
```

---

## 七、部署系統設計

### 7.1 部署管理器

```typescript
/**
 * 部署管理器
 */
class DeploymentManager {
  private sceneManager: SceneManager;
  private terrainManager: TerrainManager;
  private unitManager: UnitManager;

  // 拖曳狀態
  private isDragging: boolean = false;
  private dragUnit?: Unit;
  private dragPreview?: THREE.Sprite;

  constructor(
    sceneManager: SceneManager,
    terrainManager: TerrainManager,
    unitManager: UnitManager
  ) {
    this.sceneManager = sceneManager;
    this.terrainManager = terrainManager;
    this.unitManager = unitManager;

    this.setupEventListeners();
  }

  /**
   * 設定事件監聽
   */
  private setupEventListeners(): void {
    const canvas = this.sceneManager.getCanvas();

    canvas.addEventListener('dragstart', this.onDragStart.bind(this));
    canvas.addEventListener('drag', this.onDrag.bind(this));
    canvas.addEventListener('dragend', this.onDragEnd.bind(this));
  }

  /**
   * 開始拖曳
   */
  private onDragStart(event: DragEvent): void {
    const unitUuid = event.dataTransfer?.getData('application/x-unit-uuid');
    if (!unitUuid) return;

    // 取得單位資料
    const unitData = // 從 Store 取得...
      if (!unitData) return;

    this.dragUnit = unitData;
    this.isDragging = true;

    // 建立預覽
    this.createDragPreview(unitData);
  }

  /**
   * 拖曳中
   */
  private onDrag(event: DragEvent): void {
    if (!this.isDragging || !this.dragPreview) return;

    // 射線檢測地形位置
    const point = this.raycastTerrain(event);

    if (point) {
      this.dragPreview.position.copy(point);
      this.dragPreview.position.y += 5; // 浮動高度
    }
  }

  /**
   * 結束拖曳
   */
  private async onDragEnd(event: DragEvent): void {
    if (!this.isDragging || !this.dragUnit) return;

    // 射線檢測最終位置
    const point = this.raycastTerrain(event);

    if (point) {
      // 建立單位副本
      const deployedUnit: Unit = {
        ...this.dragUnit,
        uuid: generateUUID(),
        transform: {
          position: {
            x: point.x,
            y: point.y,
            z: point.z
          },
          rotation: { x: 0, y: 0, z: 0 }
        }
      };

      // 加入場景
      await this.unitManager.addUnit(deployedUnit);

      // 更新 Store
      // store.addUnit(deployedUnit);
    }

    // 清理
    this.cleanup();
  }

  /**
   * 射線檢測地形
   */
  private raycastTerrain(event: DragEvent): THREE.Vector3 | null {
    const canvas = this.sceneManager.getCanvas();
    const rect = canvas.getBoundingClientRect();

    const mouse = new THREE.Vector2(
      ((event.clientX - rect.left) / rect.width) * 2 - 1,
      -((event.clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.sceneManager.getCamera());

    const intersects = raycaster.intersectObjects(
      this.terrainManager.getTerrainMeshes()
    );

    if (intersects.length > 0) {
      return intersects[0].point;
    }

    return null;
  }

  /**
   * 建立拖曳預覽
   */
  private createDragPreview(unit: Unit): void {
    // 使用符號作為預覽
    const symbolTexture = SymbolEngine.generateTexture(unit.sidc);

    const material = new THREE.SpriteMaterial({
      map: symbolTexture.canvas,
      transparent: true,
      opacity: 0.7
    });

    this.dragPreview = new THREE.Sprite(material);
    this.dragPreview.scale.set(32, 32, 1);

    this.sceneManager.getScene().add(this.dragPreview);
  }

  /**
   * 清理
   */
  private cleanup(): void {
    if (this.dragPreview) {
      this.sceneManager.getScene().remove(this.dragPreview);
      this.dragPreview.material.dispose();
      this.dragPreview = undefined;
    }

    this.isDragging = false;
    this.dragUnit = undefined;
  }
}
```

---

## 八、狀態管理設計

### 8.1 Pinia Store 定義

```typescript
/**
 * ORBAT Store
 */
export const useORBATStore = defineStore('orbat', () => {
  // 狀態
  const units = ref<Record<string, Unit>>({});
  const selectedUnitId = ref<string | null>(null);

  // Getters
  const selectedUnit = computed(() => {
    if (!selectedUnitId.value) return null;
    return units.value[selectedUnitId.value];
  });

  const unitTree = computed(() => {
    return buildTree(Object.values(units.value));
  });

  // Actions
  async function addUnit(unit: Unit) {
    units.value[unit.uuid] = unit;
  }

  function updateUnit(uuid: string, updates: Partial<Unit>) {
    if (!units.value[uuid]) {
      throw new Error(ErrorCode.UNIT_NOT_FOUND);
    }
    units.value[uuid] = { ...units.value[uuid], ...updates };
  }

  function removeUnit(uuid: string) {
    if (!units.value[uuid]) {
      throw new Error(ErrorCode.UNIT_NOT_FOUND);
    }
    delete units.value[uuid];
  }

  function selectUnit(uuid: string | null) {
    selectedUnitId.value = uuid;
  }

  function clearUnits() {
    units.value = {};
    selectedUnitId.value = null;
  }

  /**
   * 建構樹狀結構
   */
  function buildTree(flatUnits: Unit[]): TreeNode[] {
    const map = new Map<string, TreeNode>();

    // 建立所有節點
    for (const unit of flatUnits) {
      map.set(unit.uuid, {
        data: unit,
        children: []
      });
    }

    // 建立樹狀關係
    const roots: TreeNode[] = [];
    for (const unit of flatUnits) {
      const node = map.get(unit.uuid)!;

      if (unit.parentId && map.has(unit.parentId)) {
        map.get(unit.parentId)!.children.push(node);
      } else {
        roots.push(node);
      }
    }

    return roots;
  }

  return {
    // 狀態
    units,
    selectedUnitId,

    // Getters
    selectedUnit,
    unitTree,

    // Actions
    addUnit,
    updateUnit,
    removeUnit,
    selectUnit,
    clearUnits
  };
});

/**
 * 場景 Store
 */
export const useSceneStore = defineStore('scene', () => {
  const currentScene = ref<Scene | null>(null);
  const isLoading = ref(false);
  const error = ref<string | null>(null);

  async function loadScene(sceneData: Scene) {
    isLoading.value = true;
    error.value = null;

    try {
      // 通知 SceneManager 載入
      await sceneManager.loadScene(sceneData);

      currentScene.value = sceneData;
    } catch (e) {
      error.value = e instanceof Error ? e.message : String(e);
    } finally {
      isLoading.value = false;
    }
  }

  function clearScene() {
    sceneManager.clearScene();
    currentScene.value = null;
  }

  return {
    currentScene,
    isLoading,
    error,
    loadScene,
    clearScene
  };
});

/**
 * UI Store
 */
export const useUIStore = defineStore('ui', () => {
  // 面板顯示狀態
  const showORBATPanel = ref(true);
  const showPropertyPanel = ref(true);
  const showTimeline = ref(true);

  // 視圖設定
  const viewMode = ref<ViewMode>(ViewMode.PERSPECTIVE);
  const showGrid = ref(true);
  const showUnitLabels = ref(true);

  // 工具狀態
  const activeTool = ref<ToolType>(ToolType.SELECT);

  function togglePanel(panel: PanelType) {
    switch (panel) {
      case PanelType.ORBAT:
        showORBATPanel.value = !showORBATPanel.value;
        break;
      case PanelType.PROPERTY:
        showPropertyPanel.value = !showPropertyPanel.value;
        break;
      case PanelType.TIMELINE:
        showTimeline.value = !showTimeline.value;
        break;
    }
  }

  function setActiveTool(tool: ToolType) {
    activeTool.value = tool;
  }

  return {
    showORBATPanel,
    showPropertyPanel,
    showTimeline,
    viewMode,
    showGrid,
    showUnitLabels,
    activeTool,
    togglePanel,
    setActiveTool
  };
});
```

---

## 九、工具函數庫

### 9.1 座標轉換工具

```typescript
/**
 * 座標轉換工具
 */
class CoordinateConverter {
  /**
   * WGS84 轉笛卡兒座標
   */
  static wgs84ToCartesian(
    latLon: LatLon,
    origin: LatLon
  ): Vector3 {
    const R = 6371000; // 地球半徑（公尺）

    // 計算相對距離
    const dx =
      (latLon.lon - origin.lon) *
      (Math.PI / 180) *
      R *
      Math.cos((latLon.lat * Math.PI) / 180);
    const dy = latLon.alt || 0;
    const dz =
      (latLon.lat - origin.lat) *
      (Math.PI / 180) *
      R;

    return { x: dx, y: dy, z: dz };
  }

  /**
   * 笛卡兒座標轉 WGS84
   */
  static cartesianToWgs84(
    position: Vector3,
    origin: LatLon
  ): LatLon {
    const R = 6371000;

    const lat =
      origin.lat +
      (position.z / R) * (180 / Math.PI);
    const lon =
      origin.lon +
      (position.x / (R * Math.cos((lat * Math.PI) / 180))) *
        (180 / Math.PI);
    const alt = position.y;

    return { lat, lon, alt };
  }
}
```

### 9.2 事件匯流排

```typescript
/**
 * 事件匯流排
 */
class EventBus {
  private listeners: Map<string, Set<Function>> = new Map();

  /**
   * 註冊事件監聽器
   */
  on(event: string, callback: Function): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }

    this.listeners.get(event)!.add(callback);

    // 返回取消訂閱函數
    return () => this.off(event, callback);
  }

  /**
   * 移除事件監聽器
   */
  off(event: string, callback: Function): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.delete(callback);
    }
  }

  /**
   * 觸發事件
   */
  emit(event: string, ...args: any[]): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        callback(...args);
      }
    }
  }

  /**
   * 一次性事件監聽器
   */
  once(event: string, callback: Function): void {
    const wrappedCallback = (...args: any[]) => {
      callback(...args);
      this.off(event, wrappedCallback);
    };

    this.on(event, wrappedCallback);
  }

  /**
   * 清除所有監聽器
   */
  clear(): void {
    this.listeners.clear();
  }
}

// 全域事件匯流排實例
export const eventBus = new EventBus();

// 事件類型定義
export enum Events {
  // 單位事件
  UNIT_ADDED = 'unit:added',
  UNIT_UPDATED = 'unit:updated',
  UNIT_REMOVED = 'unit:removed',
  UNIT_SELECTED = 'unit:selected',
  UNIT_DESELECTED = 'unit:deselected',

  // 場景事件
  SCENE_LOADED = 'scene:loaded',
  SCENE_CLEARED = 'scene:cleared',
  SCENE_SAVED = 'scene:saved',

  // UI 事件
  PANEL_TOGGLED = 'ui:panel_toggled',
  TOOL_CHANGED = 'ui:tool_changed',
  VIEW_MODE_CHANGED = 'ui:view_mode_changed'
}
```

---

## 十、效能優化策略

### 10.1 大規模單位優化

```typescript
/**
 * 單位批次渲染系統
 */
class InstancedUnitRenderer {
  private instances: Map<string, InstancedMesh> = new Map();

  /**
   * 建立批次實例
   */
  createInstances(modelPath: string, count: number): InstancedMesh {
    // 載入模型幾何
    const geometry = this.loadGeometry(modelPath);

    // 建立共用料質
    const material = new THREE.MeshStandardMaterial({
      roughness: 0.8,
      metalness: 0.2
    });

    // 建立 InstancedMesh
    const instancedMesh = new THREE.InstancedMesh(
      geometry,
      material,
      count
    );

    this.instances.set(modelPath, instancedMesh);
    return instancedMesh;
  }

  /**
   * 更新實例矩陣
   */
  updateInstanceMatrix(
    modelPath: string,
    index: number,
    position: Vector3,
    rotation: EulerAngles
  ): void {
    const mesh = this.instances.get(modelPath);
    if (!mesh) return;

    const matrix = new THREE.Matrix4();
    matrix.makeRotationY(THREE.MathUtils.degToRad(rotation.y));
    matrix.setPosition(position.x, position.y, position.z);

    mesh.setMatrixAt(index, matrix);
    mesh.instanceMatrix.needsUpdate = true;
  }
}
```

### 10.2 視錐體剔除優化

```typescript
/**
 * 視錐體剔除管理器
 */
class FrustumCullingManager {
  private frustum = new THREE.Frustum();
  private projectionMatrix = new THREE.Matrix4();

  /**
   * 更新視錐體
   */
  updateFrustum(camera: THREE.Camera): void {
    this.projectionMatrix.multiplyMatrices(
      camera.projectionMatrix,
      camera.matrixWorldInverse
    );
    this.frustum.setFromProjectionMatrix(this.projectionMatrix);
  }

  /**
   * 檢查物件是否在視錐體內
   */
  isInFrustum(object: THREE.Object3D): boolean {
    return this.frustum.intersectsObject(object);
  }

  /**
   * 批次檢查並更新可見性
   */
  updateVisibility(objects: THREE.Object3D[]): void {
    for (const obj of objects) {
      obj.visible = this.isInFrustum(obj);
    }
  }
}
```

---

*文件版本：v1.0*
*最後更新：2024-12-27*
